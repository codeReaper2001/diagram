## 142. 环形链表 II（51）

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/circularlinkedlist.png" alt="img" style="zoom: 67%;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

### 思路

双指针

设从头走到环入口需要 k 步，从链表头到入口的举例设为 a，环的长度设为 b

有 k = a + xb (x = 0, 1, 2...)

设置快慢指针，从头出发，到达环中某节点相遇，设快指针的路程为 f，慢指针的路程为 s，有：

- f = 2s
- f = s + nb

联立得到：f = nb，s = 2nb

因此相遇时已经走了nb步，还需要走a步到达环口。

如何知道a步是多少呢，此时再添加一个指针从表头开始往后走，两指针相遇时为 a 步

## 146. LRU 缓存（52）

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]
```

### 思路

维护以下核心数据结构：

- 双向链表：用于在 `O(1)` 时间内将元素移动到链表头、将链表尾元素删除
- 哈希表：`map[int]*DlistNode`，用于在 `O(1)` 时间内根据 `key` 定位到具体的链表元素，进而配合双向链表完成移动元素、删除元素的操作

## 148. 排序链表（53）

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/sort_list_1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

### 思路

归并排序

1. 使用快慢指针将链表均分成前后两个部分
2. 对前后两个部分分别归并排序
3. 排好序的前后两部分进行合并
4. 递归结束条件：node == nil || node.next == nil，即空链表和一个节点的链表是有序链表

## 152. 乘积最大子数组（54）

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

### 思路

动态规划

1. 定义 `maxMul[i]` 为包含下标 i 元素的 **乘积最大的非空连续子数组** 的乘积，定义 `minMul[i]` 为包含下标 i 元素的 **乘积最小的非空连续子数组** 的乘积
2. 初始条件：
   - `maxMul[0] = nums[0]`
   - `minMul[0] = nums[0]`
3. 状态转移方程：
   - `maxMul[i] = max(nums[i]*maxMul[i-1], nums[i]*minMul[i-1], nums[i])`
   - `minMul[i] = min(nums[i]*maxMul[i-1], nums[i]*minMul[i-1], nums[i])`

## 155. 最小栈（55）

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

**示例 1:**

```
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]
```

### 思路

1. 维护两个栈：
   - 正常存放 `int` 元素的栈 `s1`
   - 单调递减栈 `s2`
2. `push` 元素时，在单调栈中判断元素是否满足 `<=s2.top()`，如果是则填入元素，否则不填
3. `pop` 元素时，检查 `pop` 出来的元素 `val` 是否等于 `s2.top()`，是则 `s2` 也调用 `pop`，否则 `s2` 不动

## 160. 相交链表（56）

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/160_statement.png" alt="img" style="zoom:50%;" />

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

### 思路

双指针，从A出发的指针 p1 到达 null 后，从B再出发，p2则相反

p1 和 p2 相遇的地方为结果

## 169. 多数元素（57）

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1：**

```
输入：nums = [3,2,3]
输出：3
```

**示例 2：**

```
输入：nums = [2,2,1,1,1,2,2]
输出：2
```

### 思路

摩尔投票

1. 维护一个候选众数 `candidate` 和它出现的次数 `count`。初始时 `candidate` 可以为任意值，`count` 为 0；

2. 遍历数组 nums 中的所有元素，对于每个元素 `x`，在判断 `x` 之前，如果 `count` 的值为 0，我们先将 `x` 的值赋予 `candidate`，随后我们判断 `x`：

   - 如果 `x` 与 `candidate` 相等，那么计数器 `count` 的值增加 1；

   - 如果 `x` 与 `candidate` 不等，那么计数器 `count` 的值减少 1。

3. 在遍历完成后，`candidate` 即为整个数组的众数。

即初始假设第一个数为众数，后续遇到其他数字相消，相消到 0 后重新假设为众数

## 198. 打家劫舍（58）

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

### 思路

动态规划

1. 定义 `dp[i]` 为考虑 `nums[0..i]` 房屋列表情况下，能够偷窃到的最高金额
2. 初始条件：
   - `dp[0]=nums[0]`
   - `dp[1]=max(nums[0], nums[1])`
3. 状态转移方程：`dp[i]=max(nums[i] + dp[i-2], dp[i-1])`

## 200. 岛屿数量（59）

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

### 思路

dfs + 染色

## 206. 反转链表（60）

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/rev1ex1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

### 思路

简单题，注意点如下：

- 初始化 `pre = nil`, `cur = head`
- `next = cur.next` 缓存下一个数

