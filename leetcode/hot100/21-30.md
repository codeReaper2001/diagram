## 46. 全排列（21）

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

考点：回溯法

### 思路

回溯法，回溯框架：

1. 回溯结束条件：数组中的所有元素选择完了
2. 每次回溯的选择：从未选择的数字中选择一个，即如果有x个元素未选择，那么该次有x个选择

```go
func permute(nums []int) [][]int {
	res := make([][]int, 0)
	cur := make([]int, 0)
	set := make([]bool, len(nums))

	var helper func()
	helper = func() {
		if len(cur) == len(nums) {
			one := make([]int, len(cur))
			copy(one, cur)
			res = append(res, one)
			return
		}
		for i := 0; i < len(nums); i++ {
			if set[i] {
				continue
			}
			cur = append(cur, nums[i])
			set[i] = true
			helper()
			cur = cur[:len(cur)-1]
			set[i] = false
		}
	}
	helper()
	return res
}
```

## 48. 旋转图像（22）

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**示例 1：**

![img](https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/mat1.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

### 思路

1. 上下颠倒图像
2. 沿左对角线对称翻转图像

```go
func rotate(matrix [][]int) {
	// m[i][j] <-> m[len-1-i][j]
	n := len(matrix)
	for i := 0; i < n/2; i++ {
		for j := 0; j < n; j++ {
			matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j]
		}
	}
	// m[i][j] <-> m[j][i]
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
		}
	}
}
```

## 49. 字母异位词分组（23）

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。 

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

### 思路

1. 字母异位词即各个字母数量统计一致的词
2. 将单词转化为统计数组 [26]int，然后填充到以 `[26]int` 数组作为 `key`，`[]string` 作为 `value` 的map中

```go
func groupAnagrams(strs []string) [][]string {
    mp := map[[26]int][]string{}
    for _, str := range strs {
        cnt := [26]int{}
        for _, b := range str {
            cnt[b-'a']++
        }
        mp[cnt] = append(mp[cnt], str)
    }
    ans := make([][]string, 0, len(mp))
    for _, v := range mp {
        ans = append(ans, v)
    }
    return ans
}
```

时间复杂度：`O(n*(k+26))`

## 53. 最大子数组和（24）


给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

### 思路

动态规划

1. 设 dp[i] 为以元素 i 结尾的连续子数组的最大和
2. 初始条件：dp[0] = nums[0]
3. 状态转移方程：dp[i] = max(dp[i-1] + nums[i], nums[i])

最终只需要遍历 dp[0, len - 1] 获取最大值即可

## 55. 跳跃游戏（25）

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

### 思路

贪心算法

维护最远可以跳到的下标 `maxIdx`，然后在遍历数组的过程中不断更新 `maxIdx`，当 `maxIdx>=n-1` 时返回 `true`

## 56. 合并区间（26）

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

### 思路

1. 对区间列表进行排序，依据 x 进行排序
2. 两个区间进行合并操作，对于 `[x1, y1]` 和 `[x2, y2]`，如果 `y1 <= x2`，则两部分可以合并为 `[x1, y2]`

## 62. 不同路径（27）

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![img](https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

### 思路

动态规划

1. `dp[i][j]` 表示机器人到达 `(i, j)` 时的路径数量
2. 初始条件：
   - `dp[i][j]=1 (i=0)`
   - `dp[i][j]=1 (j=0)`

3. 状态转移方程：`dp[i][j] = dp[i-1][j] + dp[i][j-1] (i,j > 0)`

最终结果为 `dp[m-1][n-1]`

## 64. 最小路径和（28）

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![img](https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

### 思路

动态规划

1. `dp[i][j]` 表示到达 `(i, j)` 的最小路径和
2. 初始条件：
   - `dp[0][0]=grid[0][0]`
   - `dp[i][j]=dp[i][j-1]+grid[i][j] (i=0)`
   - `dp[i][j]=dp[i-1][j]+grid[i][j] (j=0)`
3. 状态转移方程：`dp[i][j]=min(dp[i-1][j], dp[i][j-1])+grid[i][j] (i,j > 0)`

最终结果为 `dp[m-1][n-1]`

## 70. 爬楼梯（29）

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

### 思路

动态规划

1. `dp[i]` 表示楼梯n阶时，登顶的方法数量
2. 初始条件：
   - `dp[0]=1`
   - `dp[1]=1`

3. 状态转移方程：`dp[i]=dp[i-1]+dp[i-2] (i>=2)`

## 72. 编辑距离（30）

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

### 思路

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250119022605875.png" alt="image-20250119022605875" style="zoom:50%;" />

经过转化后，本质不同的操作实际上只有三种：

- 在单词 `A` 中插入一个字符；
- 在单词 `B` 中插入一个字符；
- 修改单词 `A` 的一个字符。

动态规划：

1. `dp[i][j]` 表示 s1 前 i 个字符的子字符串和 s2 前 j 个字符的子字符串的编辑距离
2. 初始条件
   - `dp[0][0]=0`
   - `dp[i][j]=i (j=0)`
   - `dp[i][j]=j (i=0)`
3. 状态转移方程：
   - `dp[i][j]=min(dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1) (s1[i-1] != s2[j - 1])`
   - `dp[i][j]=dp[i-1][j-1] (s1[i-1] == s2[j - 1])`

