## 337. 打家劫舍 III（81）TODO

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

**示例 1:**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/rob1-tree.jpg" alt="img" style="zoom: 67%;" />

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

## 338. 比特位计数（82）

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。 

**示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

### 思路

动态规划

1. 设 `dp[i]` 表示整数 i 中二进制表示中 1 的个数

2. 初始条件：`dp[0]=0`

3. 状态转移方程：
   $$
   dp[i] = dp[i/2] + i\%2
   $$

## 347. 前 K 个高频元素（83）

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。 

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

### 思路

1. 维护小顶堆 heap，大小为 k，元素类型为 `[2]int`
2. 遍历数组 `nums`，统计 `num` 的出现频率，统计结果输出到 `map[int]int` 的映射中 `countMap`
3. 遍历  `countMap` `(num, cnt)`
   1. 堆大小不足 k，直接将 `[num, cnt]` 添加到堆中
   2. 如果 `cnt` 比对顶的 `cnt` 大，则弹出堆顶元素，然后将 `[num, cnt]` 添加到堆中
   3. 否则跳过
4. 将小顶堆的元素全部弹出作为结果输出

下面的代码展示如何使用 golang 的 heap api

```go
// 构建小顶堆
type IHeap [][2]int

func (h IHeap) Len() int {
	return len(h)
}

func (h IHeap) Less(i, j int) bool {
	return h[i][1] < h[j][1]
}

func (h IHeap) Swap(i, j int) {
	h[i], h[j] = h[j], h[i]
}

func (h *IHeap) Push(x interface{}) {
	*h = append(*h, x.([2]int))
}
func (h *IHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

func topKFrequent(nums []int, k int) []int {
	countMap := make(map[int]int)
	for _, num := range nums {
		countMap[num]++
	}
	h := &IHeap{}
	heap.Init(h)

	for num, cnt := range countMap {
		if h.Len() < k {
			heap.Push(h, [2]int{num, cnt})
		} else {
			if (*h)[0][1] < cnt {
				heap.Pop(h)
				heap.Push(h, [2]int{num, cnt})
			}
		}
	}

	res := []int{}
	for _, elem := range *h {
		res = append(res, elem[0])
	}
	return res
}
```

## 394. 字符串解码（84）

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例 1：**

```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

**示例 2：**

```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

**示例 3：**

```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

### 思路

使用栈处理

1. 创建栈 stack，元素类型为 byte
2. 遍历字符串元素 `ch`
   1. 如果 `ch != '['`，则压入栈中
   2. 此时 `ch == ']'`, 循环弹栈，直到栈顶为 `'['`
   3. 得到 `'[]'` 部分的字符串 `str`
   4. 弹出栈顶的 `'['`
   5. 循环弹栈，知道栈顶不为数字
   6. 得到数字 x
   7. 将 `newStr = str * x` 的各个字符压栈
3. 返回栈中的字符串

优化可以进一步解析数字和字符，将数字和字符串整体以 `string` 类型压入栈中

## 399. 除法求值（85）TODO

给你一个变量对数组 `equations` 和一个实数值数组 `values` 作为已知条件，其中 `equations[i] = [Ai, Bi]` 和 `values[i]` 共同表示等式 `Ai / Bi = values[i]` 。每个 `Ai` 或 `Bi` 是一个表示单个变量的字符串。

另有一些以数组 `queries` 表示的问题，其中 `queries[j] = [Cj, Dj]` 表示第 `j` 个问题，请你根据已知条件找出 `Cj / Dj = ?` 的结果作为答案。

返回 **所有问题的答案** 。如果存在某个无法确定的答案，则用 `-1.0` 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 `-1.0` 替代这个答案。

**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

**注意：**未在等式列表中出现的变量是未定义的，因此无法确定它们的答案。

**示例 1：**

```
输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
注意：x 是未定义的 => -1.0
```

**示例 2：**

```
输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]
```

## 406. 根据身高重建队列（86）TODO

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**示例 1：**

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

**示例 2：**

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

## 416. 分割等和子集（87）

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 **示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

### 思路

背包问题，动态规划

1. 问题转化为数组中是否可以选择一部分元素，使得这部分的元素和为 `target=sum/2`

2. 定义 `dp[i][j]` 为：在 `nums[0..i]` 的数组内，是否能满足元素和为 `j`

3. 状态转移方程：
   $$
   dp[i][j] = dp[i-1][j] \ || \ dp[i-1][j-nums[i]], \ j \ge nums[i] \\
   dp[i][j] = dp[i-1][j], j \lt nums[i]
   $$

4. 初始状态：

   - `dp[i][j]=true, j=0`
   - `dp[i][j]=true, i=0, j=nums[0]`

## 437. 路径总和 III（88）

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

**示例 1：**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/pathsum3-1-tree.jpg" alt="img" style="zoom:67%;" />

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

### 思路

前缀和

1. 维护前缀和的数量映射，创建 `preSum map[int]int`，`key` 为前缀和，`value` 为前缀和数量
2. 初始化：`preSum[0] = 1`

3. 遍历二叉树
   1. 当前和为 `curSum`，结果 `res += preSum[curSum - targetSum]`
   2. 将当前的和添加到 `preSum` 中：`preSum[curSum]++`
   3. 递归遍历子树
   4. `curSum -= root.val`
   5. `preSum[curSum]--`

https://leetcode.cn/problems/path-sum-iii/solutions/2784856/zuo-fa-he-560-ti-shi-yi-yang-de-pythonja-fmzo/

先更新 `res`，后更新 `preSum` 的原因见题解

## 438. 找到字符串中所有字母异位词（89）TODO

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词**

 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

## 448. 找到所有数组中消失的数字（90）TODO

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

**示例 2：**

```
输入：nums = [1,1]
输出：[2]
```

