## 1. 两数之和（1）

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

考点：`哈希表`

### 思路

1. 创建 `map[int]int` 的缓存，其中 `key` 为元素值，`val` 为元素索引
2. 遍历数组，每遍历到一个元素 `elem`，先判断与其配对的元素 `target - elem` 是否存在
   1. 如果存在则说明找到两个和为 `target` 的数，然后返回
   2. 如果不存在，则往缓存中存入当前元素，然后继续遍历

## 2. 两数相加（2）

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112214952310.png" alt="image-20250112214952310" style="zoom:67%;" />

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

考点：链表

### 思路

添加一个记录当前位相加的结果的变量cnt，设当前链表 `l1` 和 `l2` 的指针分别为 `p1`、`p2`，`cnt = p1.Val + p2.Val`

然后将 `cnt` 个位的值赋值到结果节点，然后 `cnt /= 10`，然后不断循环即可

## 3. 无重复字符的最长子串（3）

给定一个字符串 `s` ，请你找出其中不含有重复字符的**最长子串**的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

考点：哈希表 滑动窗口

### 思路

1. 以 `[0, 0]` 作为滑动窗口的起点，不断将滑动窗口向后延伸，并将滑动窗口的字符以哈希表 `hash (map[byte]bool)` 进行维护，当新加入的字符在哈希表中存在时，则不断将滑动窗口的起始点后移，直到新加入的字符在滑动窗口中不存在时，将新字符加入到滑动窗口中

2. 遍历完所有字符后结束

## 4. 寻找两个正序数组的中位数（4）TODO

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

## 5. 最长回文子串（5）

给你一个字符串 `s`，找到 `s` 中最长的 回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

考点：动态规划

### 思路

问题转化为 `s[x..y]` 是否为回文字符串，如果可以知道 `s[x..y] (0 <= x <= y < n)` 的所有情况，则可以统计得到最长的回文字符串

这个问题可以通过求解子问题不断迭代解决

1. 定义：设 `dp[x][y]` 表示 `s[x..y]` 是否为回文字符串
2. 状态转移方程：`dp[i][j] = dp[i+1][j-1] && s[i]==s[j] (i<j)`
3. 边界情况初始化：`dp[i][j]=true (i>=j)`

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112221636603.png" alt="image-20250112221636603" style="zoom:50%;" />

如上图所示，红色的地方初始值为true，由于每个值都依赖左下角已经有值，因此从右下角往上填充比较简单

填充好整个dp二维数组后，再次遍历，当 `j-i+1` 达到最大值时取值即可

## 10. 正则表达式匹配（6）TODO

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

## 11. 盛最多水的容器（7）

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])`。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112221922738.png" alt="image-20250112221922738" style="zoom:50%;" />

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

考点：贪心算法 双指针

### 思路

1. 起始指针和结束指针分别指向第一个和最后一个元素
2. 计算起始指针到结束指针围出来的面积
3. 移动指针，比较起始指针和结束指针的元素值，哪一方的元素值小，则移动哪一方的指针，然后重复二
4. 当起始指针和结束指针碰头，结束循环

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112222812385.png" alt="image-20250112222812385" style="zoom: 33%;" />

本质上解法是压缩解空间

例如一开始为 0 和 7，此时假设 0 号比较短，那么 0 号和其他的所有组合中 (1, 2, 3, ...) ，都不会比 0 到 7 更大，因为 0 号线已经达到了它的上限，取其他的线宽度都比7小，所以相当于第一次比较，就排除掉了一行的搜索空间：

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112223127894.png" alt="image-20250112223127894" style="zoom:33%;" />

然后起始变成 1，此时比较 1 号和 7 号线，假设此时 7 号线更短。同理7号线已经达到了新搜索空间的上限，和其他号的组合，都不会比 1 和 7 的组合更大，此时可以排除掉一列的搜索空间：

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112223345480.png" alt="image-20250112223345480" style="zoom:33%;" />

所以同理反复即可得到最大值

## 15. 三数之和（8）

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

**示例 2：**

```
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。
```

**示例 3：**

```
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
```

考点：哈希表

### 思路

本题为第一题的变式，相当于n个第一题的组合

第一题通过单次的循环解决，而这道题需要经过 n * n 的循环，每次循环确定一个新的target，和新的数组，然后使用第一道题的解法即可

另外要注意不能包含重复的三元组，因此需要排序并在第一层循环中去重，例如：

```java
public List<List<Integer>> threeSum(int[] nums) {
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
        if (i > 0 && nums[i - 1] == nums[i])
            continue;
        oneNumGetRes(nums, i);
    }
    return res;
}
```

## 17. 电话号码的字母组合（9）

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![image-20250112224120268](https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/image-20250112224120268.png)

### 思路

回溯法枚举所有的可能性

核心代码：

```go
func helper(cur string, digits []byte, idx int) {
	if idx == len(digits) {
		result = append(result, cur)
		return
	}
	digit := digits[idx]
	letters := letterMap[digit]
	lettersBytes := []byte(letters)
	for _, letter := range lettersBytes {
		helper(cur+string(letter), digits, idx+1)
	}
}
```

## 19. 删除链表的倒数第 N 个结点（10）

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

<img src="https://codereaper-image-bed.oss-cn-shenzhen.aliyuncs.com/image/remove_ex1.jpg" alt="img" style="zoom:50%;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

考点：双指针

### 思路

1. 构造dummy节点，接入链表头
2. 快慢指针 fast 和 slow：
   1. fast比slow要提前n个节点时，最终slow指向倒数第n个节点
   2. fast比slow要提前n+1个节点时，最终slow指向倒数第n个节点的前一个节点 √
3. slow.Next = slow.Next.Next 以此删除倒数第n个节点

