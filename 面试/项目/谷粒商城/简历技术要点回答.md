1. 使用cookie+session存储用户登录信息，并使用SpringSession解决分布式Session共享问题 
```
1) session信息存储在redis中，设置的过期时间为7天
2）session在被读写时会自动续期（getAttribute和setAttribute），更新redis中session信息的ttl
3）默认不更新，时间为400天。如果要更新Cookie，则需要在Cookie中携带时间戳信息，每次检查一下是否到时间了，如果时间快到了则续期；又或者可以在前端进行续期操作
4）用户信息保存在"loginUser"键中
```
2. 使用Redis+SpringCache缓存首页三级分类菜单、秒杀商品等热点数据，并用基于Redisson的分布式锁解决缓存击穿问题 
```
1）访问首页三级分类信息时会先查询缓存数据是否存在，如果存在则返回缓存中的内容
2）如果数据不存在（过期），会尝试先获取分布式锁，然后单线程查询数据库，最后重建缓存
3）修改数据库后如何保证缓存一致性？
① 加分布式读写锁，这个场景属于 读>>写 的场景，加上读写锁后，读读并发，读写互斥，写写互斥，所以可以保证修改数据库和更新缓存的原子性。当然读数据过程中还可能出现数据失效，此时还需加入互斥锁避免缓存击穿
rwLock
lock
读 -> 
rwLock.readLock(); 
data = 读缓存();
if(data 为空) {
	lock.lock();
	读数据库并重建缓存
	lock.unlock();
}
rwLock.unReadLock();

写 ->
rwLock.writeLock();
写数据库
写缓存
rwLock.unWriteLock();
② 使用Cannel
	1. 读操作：先读缓存，若缓存Miss，则读数据库，并用SETNX写缓存
	2. 写操作：写数据库不更新缓存
	3. Cannel监听binlog，更新缓存内容（SETEX）
```
3. 使用CompletableFuture+线程池的方式异步发送请求减少响应时间 
```
请求商品信息时：
① 请求sku基本信息
② 销售属性、spu的介绍、spu的规格参数、sku的图片信息
```
4. 基于RabbitMQ的死信延时队列实现订单业务的最终一致性分布式事务方案 
```
① 上架商品时锁库存，根据秒杀场结束时间添加解锁剩余未秒杀商品的定时任务
② 下单后订单放到30min延时队列，并锁定库存，此时也发送一个库存信息到解锁库存延时队列(50min)，当30min后消息变成死信进入死信队列，此时消费消息：1）未付款，设置订单状态为已取消 2）已付款，不进行操作
50min后解锁库存消息进入死信队列，消费消息：1）订单不存在或已取消，解锁库存 2）已支付等状态，不进行操作
```
5. 使用Spring定时任务上架秒杀商品，使用Redisson信号量解决超卖问题，并使用RabbitMQ进行流量削峰和微服务解耦 
```
① 优化：某商品100个库存，可以映射到4个队列，每个队列的消费者可以消费25件，提高并发度
② 用户支付后如果消息还未消费（订单还未被创建）如何解决？
收到支付宝发送的订单支付成功后，先往数据库中插入一条只包含订单号和订单状态的记录，这样在消息被消费时创建订单时此订单状态为“已支付”，不再放入队列order.delay.queue中进行延时解锁等操作
③ 用户秒杀商品流程
秒杀服务：{ 校验+抢分布式信号量 -> 生成订单相关信息放入消息队列 }
订单服务：{ 监听消息队列，获取用户即sku等相关信息生成订单 -> 将订单实体添加到消息队列(路由到order.delay.queue) (后续如果订单未支付会完成自动解锁库存的流程) }
④ 未支付如何返还秒杀场？
在上面的发送到消息队列的订单信息中添加是否是秒杀商品的标识，如果是秒杀商品则不解锁库存，而是返回到秒杀场次中
```
6. 使用Sentinel实现服务的降级和熔断等限流操作，并使用Sleuth+Zipkin作为链路追踪的解决方案